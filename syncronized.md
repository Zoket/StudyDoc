##### syncronized的锁对象

- 普通同步方法，锁是当前实例对象；
- 静态同步方法，锁匙当前类的class对象；
- 同步方法块，锁是括号里的对象。

##### Java对象头

syncronized用的锁匙存在java对象头里的。

Hotspot虚拟机的对象头主要包括**Mark Word(标记字段)**、**Klass Point(类型指针)**。Klass Point是对象指向它的类元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例。Mark Word用于存储对象自身运行时的数据，它是实现**轻量级锁**和**偏向锁**的关键。

Mark Word存储的数据有，HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但如果对象是数组类型，则需要三个机器码，多出来的一个机器码用来记录数组长度。下表是32位虚拟机的Java对象头存储结构。

| 25bit          | 4bit           | 1bit         | 2bit     |
| -------------- | -------------- | ------------ | -------- |
| 对象的HashCode | 对象的分代年龄 | 是否是偏向锁 | 锁标志位 |

Mark Word是非固定的数据结构，便于在尽量小的空间内存储尽量多的数据，它会根据对象的状态服用自己的存储空间。



##### Monitor

Monitor是一个同步工具，同城被描述为一种对象。所以Java对象都是Monitor，每个Java对象都有一把内部锁，或者叫Monitor锁。

Monitor是线程私有的数据结构，每一个线程都有一个monitor record列表，同时还有一个全局的可用列表。每一个锁住的对象都和一个monitor关联（对象头的Mark Word中的LockWord指向monitor的起始地址），同时monitor中有一个owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。monitor的结构有如下几个部分：

**Owner**：初始时为null表示当前没有任何线程拥有该monitor，当线程成功拥有该锁后保存线程唯一标识，当锁释放再次置为null。

**EntryQ**：关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor失败的线程。

**RcThis**：表示blocked或waiting在该monitor上的所有线程个数。

**Nest**：用来实现重入锁的计数。

**HashCode**：保存从对象头拷贝过来的HashCode，以及可能的GC age。

**Candidate**：用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功获取到锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值，0表示没有需要唤醒的线程，1表示要唤醒一个继任线程来竞争锁。



#### 锁优化

jdk1.6中对锁的实现引入了大量的优化，如自旋锁，适应性自旋锁，锁消除，锁粗化，偏向锁，轻量级锁等技术来减少锁操作的开销。

##### 自旋锁

线程在竞争锁的时候发现被占用，如果是重量级锁的话，线程将进入阻塞状态，在多个线程竞争，并且对象锁的锁状态只会持续很短时间的话，频繁的阻塞唤醒线程开销会很大，故引入自旋锁。

即，在锁被占用的情况下，不立即进入阻塞状态，而是执行一段无意义的循环来自主等待一段时间，之后再次尝试竞争锁。如果依然没有获取到锁，则线程立刻被挂起。

自旋锁在jdk1.4.2中引入，默认关闭，可以使用-XX:+UseSpinning开启，在jdk1.6中默认开启，自旋次数默认为10次，可以通过-XX:PreBlockSpin来调整。

##### 适应自旋锁

由于线程等待时间的不确定性，很可能自旋次数设置为10次，但是在线程自旋的过程中锁已经被释放了，会造成无意义的损耗。故出现自适应自旋锁。自旋次数将不再固定，具体数值由前一次锁的自旋时间及锁的持有者状态来决定。

##### 锁消除

主要针对于自带锁的数据结构来说，如果使用此对象完全不会有用到锁的地方，即对象没有逃逸到方法之外，那么JVM会自动将数据架构的锁去掉，来避免不必要的锁性能开销。例子如下：

```java
public void vectorTest() {
    Vector<String> vector = new Vector<String>();
    for (int i = 0; i < 10; i++) {
        vector.add(i + "");
    }
    System.out.println(vector);
}
```



##### 锁粗化

简单的说，是将多个连续的加锁，解锁操作连接在一起，将锁的粒度粗化为范围更大的锁，用更大的同步范围换取减少加锁解锁的次数。如上例，在循环中vector的add操作每次都要加锁，那么JVM会把这连续的10次加锁合成更大的锁，即加锁操作会移到for循环之外。





锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。锁可以升级，不可降级，是为了提高获得锁和释放锁的效率。

##### 轻量级锁

轻量级锁主要是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取。

- 获取锁
  1. 判断当前对象是否处于无锁状态（Mark Word为HashCode、GC age、0[不是偏向锁]、01[无锁状态]）,若是则JVM将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的Mark Word拷贝（Displaced Mark Word）；否则执行步骤3；
  2. JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志变为00，执行同步操作；如果失败则执行步骤3；
  3. 判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，直接执行同步操作；否则说明该锁对象被其它线程抢占了，根据情况进行自旋多次尝试获取，如果继续失败，轻量级锁将膨胀为重量级锁，锁标志位变为10，自身以及后面等待的线程将进入阻塞状态。
- 释放锁
  1. 取出在获取轻量级锁匙保存在Displaced Mark Word中的数据；、
  2. 用CAS操作将去除的数据替换到当前对象的Mark Word中，如果成功，则说明锁释放成功，失败则执行步骤3；
  3. 如果CAS操作替换失败，即当前对象的Mark Word内容相对于Lock Record有所更改，比如有其他线程在获取锁时没有成功并且将锁膨胀为重量级锁，改变了锁标志位，则需要在释放锁的同时唤醒被挂起的线程。

对于轻量级锁，其性能提升的依据是“对于绝大部分锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据，则在互斥开销外还有额外的CAS操作开销，使得轻量级锁在多线程竞争的情况下比重量级锁更慢。

##### 偏向锁

偏向锁主要解决无竞争下的锁性能问题。为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，减少CAS的开销。

- 获取锁
  1. 检查Mark Word是否为可偏向状态，即偏向锁状态为1（可偏向），锁标志位为01（无锁状态），若为可偏向状态，执行步骤2；若为不可偏向状态，则执行轻量级锁流程；
  2. 测试Mark Word中是否存有当前线程的ID，如果有，执行同步体，如果没有，执行步骤3；
  3. 如果Mark Word中不是当前线程ID(两种情况，线程ID为空或者是其他线程的ID)，则通过CAS操作尝试将当前线程ID更新到Mark Word中以获取该锁，获取成功则持有偏向锁，执行同步体，若获取失败执行步骤4；
  4. CAS获取失败，证明出现多线程竞争情况，当到达全局安全点时，获得偏向锁的线程被挂起，立即进入轻量级锁步骤，即：复制锁的Mark Word到当前线程的栈帧Lock Record中，并将Mark Word CAS更新为指向Lock Record的指针。至此偏向锁被撤销，原挂起线程继续执行同步代码。