### HashMap原理和实现



#### 内部结构

- JDK1.8之前

  由数组和链表组成，也称为*链表散列*。每添加一对k-v，即计算key的hashCode，将值放在数组对应的位置；若hashCode相同，则通过**拉链法**来解决，即将冲突的值在同一位置拉起一个链表，相同hashCode的值都存在数组的同一位置的链表当中。

  如果定位到的数组位置不含链表（当前entry的next指向null），那么对于查找，添加等操作很快，仅需一次寻址；如果定位到的数组包含链表，对于添加操作时间复杂度还是O(1)，但对于查找则需要遍历链表来查找，通过key对象的equals方法注意对比来查找是否含有value值。

- JDK1.8之后

  和1.8之前的区别主要是在解决哈希冲突的时候，将链表长度大于阀值（默认为8）的时候，将链表转化为红黑树，以减少搜索时间。

#### HashMap属性

`static final int DEFAULT_INITIAL_CAPACITY = 1 << 4；`

	初始容量：16（1 << 4即二进制的1左移4位，0001变为1000，即为二进制的16）

`static final int MAXIMUN_CAPACITY = 1 << 30;`

	最大容量：1073741824

`static final float DEFAULT_LOAD_FACTOR = 0.75f;`

	默认填充因子：0.75

`static final int TREEIFY_THRESHOLD = 8;`

	链表转树的阀值：8

`static final int MIN_TREEIFY_CAPACITY = 64;`

	桶中结构转化为红黑树对应的table的最小大小

`transient Node<k,v>[] table;`

	存储元素，长度总是2的幂次倍

`transient Set<map.entry<k,v>> entrySet;`

	存放具体元素的集

`transient int size;`

	存放元素的个数，不等于数组的长度

`transient int modCount;`

	每次扩容和更改map结构的计数器

`int threshold;`

	临界值，当实际大小（容量*加载因子）超过临界值时，会进行扩容

`final float loadFactor;`

	加载因子，控制数组存放数据的疏密程度，太大会导致查找元素效率低，太小会浪费空间。

#### HashMap源码方法

1. **hash()方法**

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

在return的三目运算中，首先判断了key是否为空，是则默认其hash值为0，否则利用key的类型自带的哈希函数求出其散列值，最后将这部分值和二进制右移16位的h做异或并返回。

这个函数被称为“扰动函数”。因为32位hash值区间过大，大概有40亿映射空间，虽然碰撞概率不大，但是区间过大，内存存不下，所以要用数组长度来对hash值做取模运算，得到余数来当成table的数组下标存储数据。源码中使用indexFor()函数完成这个操作：

```java
static int indexFor(int h, int length) {
    return h & (length - 1);
}
```

这个函数作用就是将hash值和数组长度-1的值做了一个“与”操作。HashMap的数组长度取2的整数次幂的原因在于此：2的n次方-1的二进制正好是n个1，相当于一个“低位掩码”，和hash值“与”的结果就是hash值的高位全部归零，只保留最后n位，这大大缩小了hash值的范围，可以用作数组下标访问了。以下是栗子🌰：

>     10100101 11000100 00100101
>
>&  00000000 00000000 00001111
>
>------------------------------------------------
>
>    00000000 00000000 00000101  //高位全部归零，只保留末四位

hash值缩小的问题是，范围的缩小带来的哈希碰撞概率会更大。*更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。*这个时候“扰动函数”就会起到作用。

上面说到，hash()函数本质上是将key的hash值和其右移16位后的值做异或运算，右移16位正好是32的一半，也就是将32位的hash值的高16位和低16位做了异或，这样*是为了**混合原始哈希码的高位和低位，以此来加大低位的随机性**。并且混合后的低位掺杂了高位的部分特征，这样高位的信息也变相的保留下来*。

>         h=hashCode(): 1111 1111 1111 1111 1111 0000 1110 1010
>
>-------------------------------------------------------------------------------------------
>
>                                h: 1111 1111 1111 1111 1111 0000 1110 1010
>    
>                     h>>>16: 0000 0000 0000 0000 1111 1111 1111 1111
>
>    hash=h^(h>>>16): 1111 1111 1111 1111 0000 1111 0001 0101
>
>------
>
>                             n-1: 0000 0000 0000 0000 0000 0000 0000 1111
>    
>                          hash: 1111 1111 1111 1111 0000 1111 0001 0101
>    
>               (n-1)&hash: 0000 0000 0000 0000 0000 0000 0000 0101 = 5

至此梳理出HashMap确定table数组下标的步骤：

1. 根据key的类型自带的哈希函数求出key的hash值；
2. 将hash值通过扰动函数将自身高位和地位做“异或”，加大随机性；
3. 将扰动过的hash值和数组长度-1，即低位掩码做“与”，截取hash值低位，得到将要存储的数组下标。

（“hash()方法”部分内容参考和引用知乎“胖君”回答：[JDK 源码中 HashMap 的 hash 方法原理是什么？](https://www.zhihu.com/question/20733617/answer/111577937)感谢大神指点^_^)

（注：jdk1.8之前这个扰动函数做了四次异或，而jdk1.8之后改为了一次，根据1.8中的注释，这个改动和1.8中将链表部分优化为红黑树有关。）

