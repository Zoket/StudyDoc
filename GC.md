#### GC

##### 垃圾回收第一步：判断对象是否可回收

1. 引用计数算法

   给对象一个引用计数器，每对这个对象有一个引用，计数器就+1，当引用失效，给计数器-1，任何时候计数器为0的时候，这个对象就是不会再被使用。

   但是引用计数算法的缺点是无法解决循环引用的问题。

2. 可达性分析算法

   通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到达GC Roots没有任何引用链相连，则证明此对象不可用。也就是说，遍历根节点的引用链时，每遍历一个节点则给节点做一个可达标记。当遍历完所有GC Roots时，没有标记的对象即是可以回收的对象。

   可以作为GC Roots的对象有：

   虚拟机栈（栈帧中的本地变量表）中引用的对象。

   方法区中类静态属性引用的对象。

   方法区中常量引用的对象。

   本地方法栈中JNI（一般说的Native方法）引用的对象。

   *Java GC使用的是可达性分析算法确定没有引用的对象。*

   

##### 垃圾收集第二步：执行finalize()方法

经过第一步，GC已经初步确定了需要回收的对象。但是并没有立刻回收，对象还有一个机会来避免被回收：finalize方法。GC会判断要回收的对象是否有必要执行finalize方法，如果没有必要执行，或者该对象的finalize已经执行过了（一个对象的finalize方法在生命周期内只能执行一次），则对象就将会被回收。如果有必要执行，这个对象将会放置在一个F-Queue队列中，并稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去依次从队列中取出对象，触发它的finalize方法，并且只负责触发，不关心它的结果。如果对象在finalize方法中重新将自己和引用链上的对象建立起引用关系，则它将取消被回收。

##### 垃圾收集第三步：具体回收算法

前两步已经完全确定下需要进行垃圾回收的对象。下面要进行的就是具体的回收步骤。

1. 标记-清除算法

   Mark-Sweep算法，分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收被标记的对象。这个算法是基础算法，后续的垃圾收集算法都是基于这个思路进行的改进。该算法的缺点有：

   - 效率问题，标记和清除两个过程效率都不高；
   - 空间问题，清除之后内存中会产生大量不连续的内存碎片，碎片过多会导致如果需要分配空间较大的对象，可能会因为碎片过小而没有内存可以分配，从而提前触发一次GC。

2. 复制算法

   Copying算法，将可用内存划分为大小相等的两块，每次只使用其中一块。当这块内存空间用完了，则将不需要GC回收的对象复制到另一块未被使用的内存区域上，然后把用过的内存空间一次清理掉。这样的垃圾回收比较高效，只需要挪动堆顶指针，对于堆来讲就已经完成了垃圾回收工作，不用考虑内存碎片的问题。缺点：

   - 堆可用空间将永远只有物理可用空间的一半，空间利用效率低。
   - 如果GC时对象存活率较高，则需要复制的对象过多，影响效率，使得算法的上下限依赖于对象存活率。

   一种改进的Eden-Survivor的复制算法，稍后补全。

3. 标记-整理算法

   针对于复制算法的缺点，根据老年代的特点，提出Mark-Compact算法。在标记-清除算法的基础上，标记之后不是直接清除内存，而是将所有存活的对象都向一端移动，然后直接清理掉边界以外的内存，需要操作内存的数量相对于复制算法有所减少，并且不需要额外的空间作为分配担保。

4. 分代收集算法

   根据对象存活周期的不同将内存划分为几块。一般是将Java堆分为新生代和老年代，根据各年代特点采用适当的收集算法。

   新生代中，每次GC时都有大量对象被回收，只有少量存活，则使用复制算法。

   老年代中，因为对象存活率高，没有额外空间进行分配担保，则需要使用标记-清理或者标记-整理算法来回收。