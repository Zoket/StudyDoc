#### GC

##### 垃圾回收第一步：判断对象是否可回收

1. 引用计数算法

   给对象一个引用计数器，每对这个对象有一个引用，计数器就+1，当引用失效，给计数器-1，任何时候计数器为0的时候，这个对象就是不会再被使用。

   但是引用计数算法的缺点是无法解决循环引用的问题。

2. 可达性分析算法

   通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到达GC Roots没有任何引用链相连，则证明此对象不可用。也就是说，遍历根节点的引用链时，每遍历一个节点则给节点做一个可达标记。当遍历完所有GC Roots时，没有标记的对象即是可以回收的对象。

   可以作为GC Roots的对象有：

   虚拟机栈（栈帧中的本地变量表）中引用的对象。

   方法区中类静态属性引用的对象。

   方法区中常量引用的对象。

   本地方法栈中JNI（一般说的Native方法）引用的对象。

   *Java GC使用的是可达性分析算法确定没有引用的对象。*

   

##### 垃圾收集第二步：执行finalize()方法

经过第一步，GC已经初步确定了需要回收的对象。但是并没有立刻回收，对象还有一个机会来避免被回收：finalize方法。GC会判断要回收的对象是否有必要执行finalize方法，如果没有必要执行，或者该对象的finalize已经执行过了（一个对象的finalize方法在生命周期内只能执行一次），则对象就将会被回收。如果有必要执行，这个对象将会放置在一个F-Queue队列中，并稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去依次从队列中取出对象，触发它的finalize方法，并且只负责触发，不关心它的结果。如果对象在finalize方法中重新将自己和引用链上的对象建立起引用关系，则它将取消被回收。

##### 垃圾收集第三步：具体回收算法

前两步已经完全确定下需要进行垃圾回收的对象。下面要进行的就是具体的回收步骤。

1. 标记-清除算法

   Mark-Sweep算法，分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收被标记的对象。这个算法是基础算法，后续的垃圾收集算法都是基于这个思路进行的改进。该算法的缺点有：

   - 效率问题，标记和清除两个过程效率都不高；
   - 空间问题，清除之后内存中会产生大量不连续的内存碎片，碎片过多会导致如果需要分配空间较大的对象，可能会因为碎片过小而没有内存可以分配，从而提前触发一次GC。

2. 复制算法

   Copying算法，将可用内存划分为大小相等的两块，每次只使用其中一块。当这块内存空间用完了，则将不需要GC回收的对象复制到另一块未被使用的内存区域上，然后把用过的内存空间一次清理掉。这样的垃圾回收比较高效，只需要挪动堆顶指针，对于堆来讲就已经完成了垃圾回收工作，不用考虑内存碎片的问题。缺点：

   - 堆可用空间将永远只有物理可用空间的一半，空间利用效率低。
   - 如果GC时对象存活率较高，则需要复制的对象过多，影响效率，使得算法的上下限依赖于对象存活率。

   一种改进的Eden-Survivor的复制算法，稍后补全。

3. 标记-整理算法

   针对于复制算法的缺点，根据老年代的特点，提出Mark-Compact算法。在标记-清除算法的基础上，标记之后不是直接清除内存，而是将所有存活的对象都向一端移动，然后直接清理掉边界以外的内存，需要操作内存的数量相对于复制算法有所减少，并且不需要额外的空间作为分配担保。

4. 分代收集算法

   根据对象存活周期的不同将内存划分为几块。一般是将Java堆分为新生代和老年代，根据各年代特点采用适当的收集算法。

   新生代中，每次GC时都有大量对象被回收，只有少量存活，则使用复制算法。

   老年代中，因为对象存活率高，没有额外空间进行分配担保，则需要使用标记-清理或者标记-整理算法来回收。

##### 垃圾收集器

1. Serial收集器

   它是最基本、历史最悠久的收集器，在JDK1.3.1之前是虚拟机新生代收集的唯一选择。它是单线程收集器，“单线程”的意思除了它只用一个CPU，或者说只用一个线程完成垃圾收集工作，更重要的是它在垃圾收集时，**必须暂停其他所有的工作线程**，直到收集结束。Serial收集器在**新生代**采取**复制算法**，在**老年代**称为Serial Old，采用**标记-整理算法**。它的优点：

   - 在同样单线程的情况下，相比其他收集器要简单而高效。
   - 在分配内存不是很大的情况下，需要暂停所有线程的时间一般很短，对用户来讲可以接受。

   Serial收集器到现在都是Client模式下的虚拟机的默认新生代收集器。

2. ParNew收集器

   它就是Serial收集器的多线程版本。也就是说，它在进行垃圾回收前，同样也会暂停所有用户线程，不过回收时是多线程并行，并且在**新生代**也采用**复制算法**。

   

3. Parallel Scavenge收集器

   也是一个新生代收集器，并且使用复制算法，并且是并行的多线程。

   这个收集器和其他收集器不同的是，它的关注点不是尽可能缩短垃圾收集时用户线程的停顿时间，而是旨在达到一个可控制的吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），也就是垃圾收集所用的时间占虚拟机总运行时间的占比）。

   关注停顿时间适合用在与用户交互的程序中，可以提升对用户的响应速度。而高吞吐量则可以最高效率的利用CPU时间，尽快完成运算任务，适合在后台运算且不需要太多交互的任务。

